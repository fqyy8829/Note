[toc]

# 定义集合

&emsp;&emsp;集合和 list、tuple、dict 一样都可以存放多个值，但是集合主要用于<font color=red> *__去重和关系运算__* </font>。在{}内用逗号分隔开多个元素就是集合，它具备以下三个特点：

+ 每个元素必须是不可变类型
+ 集合内没有重复的元素
+ 集合内元素无序

```python
s = {1, 2, 3, 4}
print(s)    # {1, 2, 3, 4}
```

&emsp;&emsp;也可以使用<font color=red> *__set()方法__* </font>将其它类型转换成集合类型：

```python
# 将列表转换成集合
s = set([1,2,3,4])
print(s)    # {1, 2, 3, 4}

# 将元祖转换成集合
s1 = set((1,2,3,4))
print(s1)   # {1, 2, 3, 4}

# 将字典转换成集合
s2 = set({'name':'jason',})
print(s2)   # {'name'}

# 将字符串转换成集合
s3 = set('jack')
print(s3)   # {'c', 'j', 'a', 'k'}
```

> <font color=orange>*__注意：__*</font> 但凡能被for循环遍历的数据类型（<font color=red> *__遍历出的每一个值都必须为不可变类型__* </font>）都可以传给set()转换成集合类型。

&emsp;&emsp;{}既可以用于定义dict，也可以用于定义集合，但是字典内的元素必须是 key: value 的格式，如果想定义一个空字典和空集合应该使用下面的方法：

```python
d = {} # 默认是空字典 

s = set() # 定义一个空集合
```

> <font color=orange>*__注意：__*</font> 列表类型是索引对应值，字典是key对应值，它们都可以取得单个指定的值。但是集合类型既没有索引也没有key与值对应，所以集合无法取得单个的值，而且集合主要是用于去重与关系运算，根本没有取出单个指定值这种需求。

# 关系运算

<font color=orachid>**1. 并集运算**</font>

&emsp;&emsp;并集就是求两个集合中的所有的元素，相同的元素只保留一个。可以使用<font color=red> **"|"** </font>运算符来求并集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1 | book2)    
# {'C++', 'Python', 'Go', 'C#', 'Java', 'C'}
```

&emsp;&emsp;集合本身还提供了<font color=red> *__union方法__* </font>来求两个集合的并集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1.union(book2))    
# {'C++', 'Python', 'Go', 'C#', 'Java', 'C'}
```

<font color=orachid>**2. 交集运算**</font>

&emsp;&emsp;交集就是求两个集合的共同的元素。可以使用<font color=red> **"&"** </font>运算符来求交集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1 & book2)    
# {'C', 'C++'}
```

&emsp;&emsp;集合本身还提供了<font color=red> *__intersection方法__* </font>来求两个集合的交集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1.intersection(book2))    
# {'C', 'C++'}
```

&emsp;&emsp;集合还提供了<font color=red> *__intersection_update方法__* </font>，该方法会求得两个集合的交集并将该结果赋值给目标集合：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
book1.intersection_update(book2)
print(book1) 
# {'C', 'C++'}
```

<font color=orachid>**3. 差集运算**</font>

&emsp;&emsp;差集就是去除两个集合中共有的元素，保留独有的元素。可以使用<font color=red> **"-"** </font>运算符来求差集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1 - book2)  # {'Java', 'Python'}
print(book2 - book1)  # {'Go', 'C#'}
```

&emsp;&emsp;集合本身还提供了<font color=red> *__difference方法__* </font>来求两个集合的差集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1.difference(book2))  # {'Java', 'Python'}
print(book2.difference(book1))  # {'Go', 'C#'}
```

&emsp;&emsp;集合还提供了<font color=red> *__difference_update方法__* </font>，该方法会求得两个集合的差集并将该结果赋值给目标集合：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
book1.difference_update(book2)
print(book1)    # {'Java', 'Python'}
```

<font color=orachid>**4. 对称差集**</font>

&emsp;&emsp;对称差集就是使用两个集合中独有的元素组成的集合。可以使用<font color=red> **"^"** </font>运算符来求对称差集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1 ^ book2)
# {'Java', 'Python', 'Go', 'C#'}
```

&emsp;&emsp;集合本身还提供了<font color=red> *__symmetric_difference方法__* </font>来求两个集合的对称差集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1.symmetric_difference(book2))
# {'Java', 'Python', 'Go', 'C#'}
```

&emsp;&emsp;集合还提供了<font color=red> *__symmetric_difference_update方法__* </font>，该方法会求得两个集合的对称差集并将该结果赋值给目标集合：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
book1.symmetric_difference_update(book2)
print(book1)
# {'Java', 'Python', 'Go', 'C#'}
```

<font color=orachid>**5. 相等运算**</font>

&emsp;&emsp;相等运算用来判断两个集合中的元素是否完全相同。可以使用<font color=red> **"=="** </font>运算符来进行相等运算：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1 == book2)   # False
```

&emsp;&emsp;还可以使用<font color=red> **!=** </font>运算符来判断两个集合是否不完全相同：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1 != book2)   # True
```

&emsp;&emsp;还可以使用<font color=red> **isdisjoint** </font>来判断两个集合中的元素是不是完全不相同，即两个集合中不能包含相同的元素：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"C#", "C", "Go", "C++"}
print(book1.isdisjoint(book2))   # False
```

<font color=orachid>**6. 父子集**</font>

&emsp;&emsp;Python提供了<font color=red> **>** </font>和 <font color=red>**>=（此时两个集合完全相等也会返回True）** </font>运算符来判断一个集合是不是另外一个集合的父集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"Java" ,"C" ,"C++"}
print(book1 > book2)   # True
print(book1 >= book2)   # True
```

&emsp;&emsp;同时集合也提供了<font color=red> **issuperset方法** </font>来判断一个集合是不是另外一个集合的父集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"Java" ,"C" ,"C++", "Python"}
print(book1.issuperset(book2))   # True
```

&emsp;&emsp;Python还提供了<font color=red> **<** </font>和<font color=red> **<=（此时两个集合完全相等也会返回True）** </font>运算符来判断一个集合是不是另外一个集合的子集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"Java" ,"C" ,"C++", "Python"}
print(book1 <= book2)   # True
print(book1 < book2)    # False
```

&emsp;&emsp;同时集合也提供了<font color=red> **issubset方法** </font>来判断一个集合是不是另外一个集合的子集：

```python
book1 = {"Java" ,"C" ,"C++", "Python"}
book2 = {"Java" ,"C" ,"C++", "Python"}
print(book1.issubset(book2))   # True
```

# 去重操作

&emsp;&emsp;通过集合可以实现去重的操作，比如下面是对列表的去重：

```python
book1 = ["Java", "C#", "C", "Java", "C#"]
# 首先将列表转换成集合
set_book = set(book1)
# 再将集合转换成列表
new_book = list(set_book)
# 此时列表被去重了
print(new_book) # ['C#', 'C', 'Java']
```

> <font color=orange>*__注意：__*</font> 集合去重有局限性
> 1. 只能针对不可变类型
> 2. 集合本身是无序的，去重之后无法保留原来的顺序

&emsp;&emsp;因此，针对不可变类型，并且如果需要保证顺序则可以自己编写代码实现，如：

```python
users = [
    {'name':'Funny','age':18,'sex':'male'},     
    {'name':'Jack','age':73,'sex':'male'},     
    {'name':'Tom','age':20,'sex':'female'},     
    {'name':'Funny','age':18,'sex':'male'},     
    {'name':'Funny','age':18,'sex':'male'} 
] 

new_users = [] 

for dic in users:
    if dic not in new_users:         
        new_users.append(dic) 
 
 
print(new_users)

# [
#     {'name': 'Funny', 'age': 18, 'sex': 'male'}, 
#     {'name': 'Jack', 'age': 73, 'sex': 'male'}, 
#     {'name': 'Tom', 'age': 20, 'sex': 'female'}
# ]
```

# 其它运算
## 求集合的长度

&emsp;&emsp;可以通过<font color=red> **len()方法** </font>获取集合的长度：

```python
book1 = {"Python", "C#", "C++"}
print(len(book1))   # 3
```

## 成员运算

&emsp;&emsp;可以通过<font color=red> **in** </font>和<font color=red> **not in** </font>方法判断元素是否在集合中：

```python
book1 = {"Python", "C#", "C++"}
print("C#" in book1)   # True
print("C#" not in book1)   # False
```

## 遍历集合

&emsp;&emsp;可以使用<font color=red> **for循环** </font>遍历集合：

```python
book1 = {"Python", "C#", "C++"}
for book in book1:
    print(book , end=" ")
# C# Python C++
```

## 修改集合

<font color=orachid>**1. 添加元素**</font>

&emsp;&emsp;可以通过<font color=red> **add方法** </font>给集合添加元素：

```python
book1 = {"Python", "C#", "C++"}
book1.add("C")
book1.add("C")
print(book1)
```

> <font color=orange>*__注意：__*</font>
> 1. 如果元素已经存在则不会添加该元素，以为集合中元素是不可以重复的
> 2. 添加完成后不能保证集合中元素的顺序

<font color=orachid>**2. 删除元素**</font>

&emsp;&emsp;可以通过<font color=red> **clear方法** </font>清空集合：

```python
book1 = {"Python", "C#", "C++"}
book1.clear()
print(book1)    # set()
```

&emsp;&emsp;可以通过<font color=red> **pop方法** </font>随机删除集合中的元素：

```python
book1 = {"Python", "C#", "C++"}
book1.pop()
print(book1)    # {'C#', 'Python'}
```

> <font color=orange>*__注意：__*</font> 如果在空集合上使用该方法就会报错。

&emsp;&emsp;可以通过<font color=red> **remove方法** </font>删除集合中的指定元素：

```python
book1 = {"Python", "C#", "C++"}
book1.remove("Python")
print(book1)    # {'C++', 'C#'}
```

> <font color=orange>*__注意：__*</font> 如果指定删除的元素不存在就会报错。

<font color=orachid>**3. 复制集合**</font>

&emsp;&emsp;可以通过<font color=red> **copy方法** </font>复制集合，对原来的集合的操作不会影响新的集合：

```python
book1 = {"Python", "C#", "C++"}
# 复制集合并复制给book2
book2 = book1.copy()
print(book2)    # {'C#', 'Python', 'C++'}

# 操作原来的集合不会影响book2
book1.pop()
print(book1)    # {'Python', 'C++'}
print(book2)    # {'C#', 'Python', 'C++'}
```

<font color=orachid>**4. 更新集合**</font>

&emsp;&emsp;集合提供了<font color=red> **update** </font>方法用来更新原来的集合，任何可被for循环迭代的对象都可以作为该方法的参数：

+ 如果集合中已经包含该元素，则不添加
+ 如果集合中没有包含该元素，则添加
+ 如果集合中有，但是update方法中没有传入的，则保持不变

```python
book1 = {"Python", "C#", "C++"}
book1.update(["Python", "Java"], "He")
print(book1)    # {'e', 'H', 'C++', 'Java', 'Python', 'C#'}
```