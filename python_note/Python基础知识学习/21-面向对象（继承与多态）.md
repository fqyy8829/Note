[toc]

# 继承

&emsp;&emsp;继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，当一个类继承另一类的时候，将自动获取另一个类的所有的属性和方法。原有的类称为父类，新的类称为子类，子类继承父类的所有的属性和方法，同时还有自己的属性和方法：

```python
# 定义一个父类
class Animal:
    name = "旺财"
    def info(self):
        print("Animal...")


# 定义一个继承Animal的子类
class Dog(Animal):
    def __init__(self):
        self.weight=20

    def sayHello(self):
        print("汪汪汪....")


dog1 = Dog()

# 调用父类的属性和方法
print(dog1.name)
dog1.info()
# 调用子类的属性和方法
print(dog1.weight)
dog1.sayHello()
```

> <font color=orange>*__注意：__*</font>
> 1. 首先父类必须包含在当前的文件中，并且父类必须在子类的前面
> 2. 子类的圆括号里面必须指定父类的名称

&emsp;&emsp;通过类的内置属性 <font color=red>*__\_\_bases\_\___*</font> 可以查看类继承的所有父类：

```python
# 定义一个父类
class Animal:
    name = "旺财"
    def info(self):
        print("Animal...")


# 定义一个继承Animal的子类
class Dog(Animal):
    def __init__(self):
        self.weight=20

    def sayHello(self):
        print("汪汪汪....")


print(Dog.__bases__)    # (<class '__main__.Animal'>,)
```

&emsp;&emsp;类中提供了一个 <font color=red>*__super()__* </font>函数，该函数能够让你调用父类中的方法：

```python
# 定义一个父类
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def info(self):
        print("name = {name}, age = {age}".format(name=self.name, age=self.age))


# 定义一个继承Animal的子类
class Dog(Animal):
    def __init__(self, name, age, weight):
        super().__init__(name, age)
        self.weight = weight

    def sayHello(self):
        print("汪汪汪....")


dog1 = Dog("旺财", 12, 20)
dog1.info()
print(dog1.weight)
dog1.sayHello()
```

&emsp;&emsp;在子类中还可以重写父类中的方法，只要在子类中定义一个和父类一样名字的方法即可：

```python
# 定义一个父类
class Animal:
    def sayHello(self):
        print("Hello Animal")


# 定义一个继承Animal的子类
class Dog(Animal):
    def sayHello(self):
        print("Hello Dog")


dog1 = Dog()
dog1.sayHello() # Hello Dog
```

> <font color=orange>*__注意：__*</font><br/>
> &emsp;&emsp;在Python2中有经典类与新式类之分：
> + 没有显式地继承object类的类，以及该类的子类都是经典类
> + 显式地继承object的类，以及该类的子类都是新式类。
> 
> &emsp;&emsp;在Python3中，即使没有显式地继承object，也会默认继承该类，因而在Python3中统一都是新式类。<br/>
> &emsp;&emsp;object类主要提供了一些常用内置方法的实现，如：用来在打印对象时返回字符串的内置方法\_\_str\_\_等。

# 属性查找

&emsp;&emsp;有了继承关系后，对象在查找属性时的顺序如下：<font color=red> *__先从对象自己的\_\_dict\_\_中查找，如果没有则去该类中查找，然后再去父类中找：__* </font>

```python
class Foo:
    def f1(self):
        print('Foo.f1')

    def f2(self):
        print('Foo.f2')
        self.f1()

class Bar(Foo):
    def f1(self):
        print('Bar.f1')


b = Bar()
b.f2()

# Foo.f2
# Bar.f1
```

&emsp;&emsp;b.f2()会在父类Foo中找到f2，先打印 "Foo.f2"；然后执行到 self.f1()，即：b.f1()，此时仍会按照：对象本身->类Bar->父类Foo的顺序依次找下去，在类Bar中找到f1，因而打印结果为Bar.f1。


&emsp;&emsp;如果父类不想让子类覆盖自己的方法，可以采用双下划线开头的方式将方法设置为私有的：

```python
class Foo:
    def __f1(self): 
        # 变形为_Foo__f1
        print('Foo.f1')

    def f2(self):
        print('Foo.f2')
        self.__f1() 
        # 变形为self._Foo__f1,因而只会调用自己所在的类中的方法


class Bar(Foo):
    def __f1(self): 
        # 变形为_Bar__f1
        print('Bar.f1')


b=Bar()
b.f2() #在父类中找到f2方法，进而调用b._Foo__f1()方法，同样是在父类中找到该方法Foo.f1

# Foo.f2
# Foo.f1
```