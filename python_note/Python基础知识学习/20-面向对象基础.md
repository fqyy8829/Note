[toc]

# 类的定义与实例化

&emsp;&emsp;面向对象编程就是要创造出一个个的对象，把原本分散开的相关数据与功能整合到一个个的对象里，这么做既方便使用，也可以提高程序的解耦合程度，进而提升了程序的可扩展性。面向对象的基本思路就是把程序中要用到的、相关联的数据与功能整合到对象里，然后再去使用。


&emsp;&emsp;首先需要做的就是在程序中定义出类，然后调用类产生对象：

```python
class Dog:
    name='旺财' # 数据
    def sit(self): # 功能
        print('sit down')
```

> <font color=orange>*__注意：__*</font> 根据约定，首字母大写的名称指的是类，这个类没有圆括号。

&emsp;&emsp;类体最常见的是变量的定义和函数的定义，但其实类体可以包含任意Python代码，可以通过 <font color=red>*__\_\_dict\_\___*</font> 来查看类这个容器内的东西：

```python
class Dog:

    name='旺财' # 数据
    
    def sit(self): # 功能
        print('sit down')
        
        
print(Dog.__dict__) 
# {'__module__': '__main__', 'name': '旺财', 'sit': <function Dog.sit at 0x00000000021CAA60>, '__dict__': <attribute '__dict__' of 'Dog' objects>, '__weakref__': <attribute '__weakref__' of 'Dog' objects>, '__doc__': None}
```

&emsp;&emsp;调用类的过程称为类的实例化，拿到的返回值就是程序中的对象（或称为一个实例）：

```python
class Dog:
    name='旺财' # 数据
    def sit(self): # 功能
        print('sit down')
        
        
dog1 = Dog()    # 实例化
```

&emsp;&emsp;如果想在实例化的过程中为对象定制各自独有的数据，需要在类内部新增一个<font color=red> *__\_\_init\_\_方法__* </font>，如下：

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sit(self):
        print(f"{self.name} is now sitting")
```

&emsp;&emsp;类中的函数称为方法，<font color=red> *__\_\_init\_\___* </font>是一个特殊的方法，每当使用类创建新实例的时候，Python都会自动调用它。方法中的self参数是不可以省略的，并且必须位于其它参数的前面。它是一个指向实例本身的引用，让实例能够访问类中的属性和方法：

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sit(self):
        print(f"{self.name} is now sitting")

dog1 = Dog("Jack", 12)
dog2 = Dog("Helen", 15)
dog1.sit()  # Jack is now sitting
dog2.sit()  # Helen is now sitting
```

&emsp;&emsp;在类的实例化过程中发生了三件事：

1. 产生一个控对象
2. 自动调用 \_\_init\_\_ 方法
3. 返回对象

# 隐藏属性

&emsp;&emsp;Python的Class机制采用双下划线开头的方式将属性隐藏起来（设置成私有的），但其实这仅仅只是一种变形操作，类中所有双下滑线开头的属性都会在类定义阶段、检测语法时自动变成<font color=red> *__"\_类名\_\_属性名"__* </font>的形式：

```python
class Foo:
    __N = 0 # 变形为_Foo__N

    def __init__(self):
        self.__x=10 # 变形为self._Foo__x

    def __f1(self): # 变形为_Foo__f1
        print('__f1 run')

    def f2(self):
        self.__f1() #变形为self._Foo__f1()


# print(Foo.__N)  # 会报错
print(Foo._Foo__N)  # 0
```

&emsp;&emsp;这种变形需要注意的问题是：

1. 在类外部无法直接访问双下滑线开头的属性，但知道了类名和属性名就可以拼出名字：<font color=red> *__\_类名\_\_属性__* </font>，然后就可以访问了，如：<font color=red> **Foo.\_Foo\_\_N** </font>，所以说这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形：

```python
class Foo:
    __N = 0 # 变形为_Foo__N


Foo.__dict__
# mappingproxy({..., '_Foo__N': 0, ...})
print(Foo._Foo__N) # 0
```

2. 在类内部是可以直接访问双下滑线开头的属性的，比如：<font color=red> *__self.\_\_f1()__* </font>，因为在类定义阶段类内部双下滑线开头的属性统一发生了变形：

```python
class Foo:
    def f1(self):
        self.__f2()

    def __f2(self):
        print("f2函数被调用....")

foo = Foo()
foo.f1()    # 内部直接调用
foo._Foo__f2() # 外部调用
```

3. 变形操作只在类定义阶段发生一次，在类定义之后的赋值操作不会变形：

```python
class Foo:
    __N = 0

# 内部的
print(Foo._Foo__N)

# 外部的
Foo.__A = 10
print(Foo.__A)
```

# 开放接口

&emsp;&emsp;定义属性就是为了使用，所以隐藏并不是目的。 

## 隐藏数据属性

&emsp;&emsp;将数据隐藏起来就限制了类外部对数据的直接操作，然后类内应该提供相应的接口来允许类外部间接地操作数据，接口之上可以附加额外的逻辑来对数据的操作进行严格地控制：

```python
class Teacher:
    def __init__(self,name,age): 
    #将名字和年纪都隐藏起来
        self.__name=name
        self.__age=age

    def tell_info(self): 
        #对外提供访问老师信息的接口
        print('姓名:%s,年龄:%s' %(self.__name,self.__age))
    
    def set_info(self,name,age): 
    #对外提供设置老师信息的接口，并附加类型检查的逻辑
        if not isinstance(name,str):
            raise TypeError('姓名必须是字符串类型')
        if not isinstance(age,int):
            raise TypeError('年龄必须是整型')
        self.__name=name
        self.__age=age
        
t=Teacher('lili',18)
t.set_info('LiLi','19') # 年龄不为整型，抛出异常

# Traceback (most recent call last):
#  File "<stdin>", line 1, in <module>
#  File "<stdin>", line 11, in set_infoTypeError: 年龄必须是整型
  
t.set_info('LiLi',19) # 名字为字符串类型，年龄为整形，可以正常设置
t.tell_info() # 查看老师的信息姓名:LiLi,年龄:19
```

## 隐藏函数属性

&emsp;&emsp;隐藏函数属性的目的的是为了隔离复杂度，例如：ATM程序的取款功能，该功能由很多其它功能组成（如：插卡、身份认证、输入金额、打印小票、取钱等），而对使用者来说,只需要开发取款这个功能接口即可,其余功能我们都可以隐藏起来：

```python
class ATM:
    def __card(self): #插卡
        print('插卡')
    def __auth(self): #身份认证
        print('用户认证')
    def __input(self): #输入金额
        print('输入取款金额')
    def __print_bill(self): #打印小票
        print('打印账单')
    def __take_money(self): #取钱
        print('取款')
    def withdraw(self): #取款功能
        self.__card()
        self.__auth()
        self.__input()
        self.__print_bill()
        self.__take_money()

obj=ATM()
obj.withdraw()
```

&emsp;&emsp;总结隐藏属性与开放接口，本质就是为了明确地区分内外：类内部可以修改封装内的东西而不影响外部调用者的代码；而类外部只需拿到一个接口，只要接口名、参数不变，则无论设计者如何改变内部实现代码，使用者均无需改变代码。

# property

&emsp;&emsp;Python专门提供了一个装饰器property，<font color=red> *__可以将类中的函数 "伪装" 成对象的数据属性__* </font>，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果，例如：

```python
class People:
    def __init__(self,name,weight,height):
        self.name=name
        self.weight=weight
        self.height=height

    @property
    def bmi(self):
        return self.weight / (self.height**2)
 
obj=People('lili',75,1.85)
print(obj.bmi) 
# 触发方法bmi的执行，将obj自动传给self，执行后返回值作为本次引用的结果21.913805697589478
```

&emsp;&emsp;使用property有效地保证了属性访问的一致性。另外property还提供设置和删除属性的功能，如下：

```python
class Foo:
    def __init__(self, val):
        self.__NAME = val  # 将属性隐藏起来

    @property
    def name(self):
        return self.__NAME

    @name.setter
    def name(self, value):
        if not isinstance(value, str):  # 在设定值之前进行类型检查
            raise TypeError('%s must be str' % value)
        self.__NAME = value  # 通过类型检查后,将值value存放到真实的位置self.__NAME

    @name.deleter
    def name(self):
        raise PermissionError('Can not delete')


f = Foo('lili')
print(f.name)
f.name = 'LiLi'  # 触发name.setter装饰器对应的函数name(f,’Egon')
print(f.name)
# f.name = 123  # 触发name.setter对应的的函数name(f,123),抛出异常TypeError
# del f.name  # 触发name.deleter对应的函数name(f),抛出异常PermissionError
```

# 方法的分类

&emsp;&emsp;类中定义的函数分为两大类：<font color=red> *__绑定方法和非绑定方法__* </font>，其中绑定方法又分为绑定到对象的对象方法和绑定到类的类方法。

## 绑定方法

&emsp;&emsp;在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器<font color=red> **@classmethod** </font>后，该函数就绑定到了类：

```python
class ConnectTool:
    def __init__(self, username, password):
        self.username = username
        self.password = password

    @classmethod
    def create(cls):
        return cls("张三", 18)


ins = ConnectTool.create()
print(ins.username)
```

&emsp;&emsp;绑定到类的方法就是专门用来给类使用的，但其实对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用是没有意义的，并且容易引起混淆。这也是Python与其它面向对象语言对象语言的区别之一，在其它语言（如：Ruby）中，绑定到类的方法与绑定到对象的方法是严格区分开的。类方法通常用来在\_\_init\_\_的基础上提供额外的初始化实例的方式。

## 非绑定方法

&emsp;&emsp;为类中某个函数加上装饰器<font color=red> **@staticmethod** </font>后，该函数就变成了非绑定方法，也称为静态方法。该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，因而没有自动传值那么一说：

```python
import uuid

class MySQL:
    def __init__(self, host, port):
        self.id = self.create_id()
        self.host = host
        self.port = port

    @staticmethod
    def create_id():
        return uuid.uuid1()

conn = MySQL('127.0.0.1',3306)
print(conn.id) #100365f6-8ae0-11e7-a51e-0088653ea1ec

# 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法

print(MySQL.create_id)  # <function MySQL.create_id at 0x7fb2fc0d23a0>
print(conn.create_id)   # <function MySQL.create_id at 0x7fb2fc0d23a0>
```

> <font color=orange>**总结绑定方法与非绑定方法的使用：**</font>若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法。