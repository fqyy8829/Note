[toc]

# 基础概念

&emsp;&emsp;软件的设计应该遵循<font color=red> *__开闭原则__* </font>（对扩展是开放的、对修改是封闭的）:

+ <font color=green>**对扩展开放：**</font>意味着有新的需求或者需求发生变化的时候，可以对现有代码进行扩展以适应新的情况
+ <font color=green>**对修改封闭：**</font>意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改

&emsp;&emsp;软件的所有功能的源代码以及调用方式都应该避免修改，但是软件经常会出现需求变化，这个时候又必须为程序提供扩展的可能性，这就用到了装饰器。"装饰" 是指为被装饰对象添加新的功能，装饰器与被装饰的对象均可以使用任意可调用对象（函数、方法或者类）。

&emsp;&emsp;概括地说，<font color=red> *__装饰器的作用是在不修改对象源代码和调用方式的前提下为被装饰对象添加额外的功能__* </font>，常用于有切面需求的场景，如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器就可以抽离出大量与函数功能本身无关的雷同代码并进行复用。

# 装饰器的实现

&emsp;&emsp;函数装饰器可以分为：<font color=red> *__无参装饰器和有参装饰器__* </font>，它们的实现原理都是一样的，都是基于 <font color=red> *__函数嵌套+闭包+函数对象__* </font>的组合使用的。

## 无参装饰器的实现

&emsp;&emsp;如果想为函数添加统计代码执行时间的功能，可以使用下面的方法：

```python
import time

def index():
  start_time = time.time()
  time.sleep(3)    
  print('Welcome to the index page')
  stop_time = time.time()
  print(stop_time - start_time)

index() #函数执行
```

&emsp;&emsp;上面的案例虽然实现了该功能，但是违背了不修改被装饰对象的源代码的原则，所以我们可以将代码修改成下面的样子：

```python
import time 

def index(): 
  time.sleep(3)     
  print('Welcome to the index page') 

start_time=time.time()
index() #函数执行
stop_time=time.time()
print( stop_time-start_time )
```

&emsp;&emsp;这里虽然实现了函数执行时间统计的功能，但是我们可能还要统计其它函数的执行时间，这时候就需要考虑代码的复用性，所以我们可以将该功能做成一个单独的工具，将需要执行统计时间的函数以参数的形式传入：

```python
import time 

def index(): 
  time.sleep(3)     
  print('Welcome to the index page')


def wrapper(func): 
  # 通过参数接收外部的值    
  start_time=time.time()    
  res=func()    
  stop_time=time.time()    
  print( stop_time-start_time )    
  return res

wrapper(index)
wrapper(index)
```

&emsp;&emsp;上面的代码虽然实现了统计时间的代码的复用，但是却违背了不能修改被装饰对象的调用方式的原则，所以我们可以使用函数体传值的方式（即将值包给函数）：

```python
def timer(func):    
  def wrapper(): 
    # 引用外部作用域的变量func        
  	start_time=time.time()        
  	res=func()        
  	stop_time=time.time()        
    print('run time is %s' %(stop_time-start_time))        
    return res    
  return wrapper
```

&emsp;&emsp;此时便可以在不修改被装饰函数源代码和调用方式的前提下为其加上统计时间的功能，但是需要事先执行一次timer将被装饰的函数传入，返回一个闭包函数wrapper重新赋值给index：

```python
index=timer(index)  #得到index=wrapper，wrapper携带对外作用域的引用：func=原始的index
index() # 执行的是wrapper()，在wrapper的函数体内再执行最原始的index
```

&emsp;&emsp;但这里还忽略了一个问题，如果此时被装饰的函数是带参数的就会抛出异常：

```python
def home(name):    
  time.sleep(5)    
  print('Welcome to the home page',name)
 
home=timer(home)
home('Jack')
#抛出异常TypeError: wrapper() takes 0 positional arguments but 1 was given
```

&emsp;&emsp;这里之所以会抛出异常，是因为 <font color=red>*__home('Jack')__*</font> 其实调用的是 <font color=red>*__wrapper('Jack')__* </font>，而函数wapper是没有参数的。为了能够满足被装饰函数的所有情况，可以使用 <font color=red>*__\*args + \*\*kwargs__* </font> 组合，此时就可以用timer来装饰不带参数和带任意参数的函数了：

```python
def timer(func):    
  def wrapper(*args,**kwargs):        
      start_time=time.time()        
      res=func(*args,**kwargs)        
      stop_time=time.time()        
      print(stop_time-start_time)        
      return res    
  return wrapper
```

&emsp;&emsp;Python提供了专门的装饰器语法来取代<font color=red> *__index=timer(index)__* </font>的形式，需要在被装饰对象正上方单独一行添加<font color=red> *__@装饰器名称__* </font>，当解释器解释到这里时，就会调用对应的装饰器函数，并且把正下方的函数名当做实参传入，然后将返回的结果重新赋值给原来的函数名：

```python
@timer # index=timer(index)
def index():    
  time.sleep(3)    
  print('Welcome to the index page')    
  return 200


@timer # index=timer(home) 
def home(name):    
  time.sleep(5)    
  print('Welcome to the home page’,name)
```

&emsp;&emsp;可以同时叠加多个装饰器：

```python
@deco3
@deco2
@deco1
def index():    
  pass

# index=deco3(deco2(deco1(index)))
```

## 有参装饰器的实现

&emsp;&emsp;假如现在有这样一个装饰器：

```python
def deco(func):       
  def wrapper(*args,**kwargs):            
    if driver == 'file':                
      # 编写基于文件的认证,认证通过则执行res=func(*args,**kwargs),并返回res            
    elif driver == 'mysql':                
      #编写基于mysql认证,认证通过则执行res=func(*args,**kwargs),并返回res        
  return wrapper
```

&emsp;&emsp;此时函数wrapper需要一个driver的参数，而函数deco和wrapper的参数都有其特定功能，不能用来接收其它类别的参数。这个时候可以在deco的外部再包一层函数auth，该函数专门用来接收额外的参数：

```python
def auth(driver):    
  def deco(func):        
    # ……    
  return deco


# 先调用auth_type(driver='file')，得到@deco，deco是一个闭包函数，包含了对外部作用域名字driver的引用，@deco的语法意义与无参装饰器一样
@auth(driver='file') 
def index():         
  pass

@auth(driver='mysql') 
def home():    
  pass  
```

## 装饰器的完善

&emsp;&emsp;函数提供了<font color=red> \_\_name\_\_ 和 \_\_doc\_\_ </font> 属性，分别表示函数的名称和文档注释：

```python
def index():    
  '''        
  index方法        
  打印一条语句    
  '''    
  print("Hello world")

print(index.__name__, index.__doc__)
```

&emsp;&emsp;也可以通过<font color=red> *__help(函数名)__* </font>来查看函数的文档注释，其本质就是查看函数的 \_\_doc\_\_ 属性：

```python
def index():    
  '''        
  index方法        
  打印一条语句    
  '''    
  print("Hello world")
  print(help(index))
```

&emsp;&emsp;但是对于被装饰之后的函数，通过help函数发现查看到的是闭包函数的信息：

```python
@timer
def home(name):    
  '''    
  home page function    
  :param name: str    
  :return: None    
  '''    
  time.sleep(5)    
  print('Welcome to the home page',name)
 

print(help(home))
  '''
  打印结果：
  Help on function wrapper in module __main__:
  wrapper(*args, **kwargs)
  None
  '''
```

&emsp;&emsp;如果想要保留原函数的文档和函数名属性，需要通过下面的方法修正装饰器：

```python
def timer(func):    
  def wrapper(*args,**kwargs):        
    start_time=time.time()        
    res=func(*args,**kwargs)        
    stop_time=time.time()        
    print('run time is %s' %(stop_time-start_time))        
    return res    
  wrapper.__doc__=func.__doc__    
  wrapper.__name__=func.__name__    
  return wrapper
```

&emsp;&emsp;但是这种方式过于麻烦，在functools模块下提供了一个装饰器wraps专门用来帮助实现这件事情：

```python
from functools import wraps
def timer(func):    
  @wraps(func)    
  def wrapper(*args,**kwargs):        
    start_time=time.time()        
    res=func(*args,**kwargs)        
    stop_time=time.time()        
    print('run time is %s' %(stop_time-start_time))        
    return res    
  return wrapper
```