[toc]

# 定义元祖

&emsp;&emsp;列表非常适合用于存储在程序运行期间可能变化的数据集，因为列表是可以修改的；然而有时候你需要创建一系列不可修改的元素，这时候就可以使用元祖。Python将不能修改的值称为不可变的，而不可变的列表就是元祖。

&emsp;&emsp;元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改，即<font color=red> *__元组相当于不可变的列表，用于记录多个固定不允许修改的值，单纯用于取__* </font>。元祖看起来很像列表，只不过是使用圆括号替换掉中括号，定义了元祖后就可以像访问列表一样访问元祖：

```python
point = (12, 23)
print(point)    # (12, 23)
print(point[0]) # 12
```

&emsp;&emsp;如果尝试修改元祖的值就会报错：

```python
point = (12, 23)
point[0] = 14

# TypeError: 'tuple' object does not support item assignment
```

&emsp;&emsp;严格的说元祖是由逗号标识的，圆括号只是让元祖看起来更整洁、更清晰。如果你只定义一个元素的元祖，必须在该元素后面加上逗号：

```python
numbers = (12,)
numbers1 = (12)
print(type(numbers1))   # <class 'int'>
print(type(numbers))    # <class 'tuple'>
```

&emsp;&emsp;虽然不可以修改元祖中的元素值，但是可以给元祖对象本身重新赋值：

```python
numbers = (1, 2, 3, 4)
numbers = (1, 2)
print(numbers) # (1, 2)
```

&emsp;&emsp;相对于列表元祖是更简单的数据结构，如果需要存储的一组数据在整个生命周期内都不变，建议使用元祖。

# 类型转换

&emsp;&emsp;但凡能被for循环的遍历的数据类型都可以传给tuple()转换成元组类型，tuple()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到元组中：

```python
tuple('wdad') # 结果：('w', 'd', 'a', 'd') 
tuple([1,2,3]) # 结果：(1, 2, 3)
tuple({"name":"jason","age":18}) # 结果：('name', 'age')
tuple((1,2,3)) # 结果：(1, 2, 3)
tuple({1,2,3,4}) # 结果：(1, 2, 3, 4)
```