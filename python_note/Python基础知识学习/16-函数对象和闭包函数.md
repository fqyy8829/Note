[toc]

# 函数对象

&emsp;&emsp;函数对象指的是函数可以被当作“数据”来处理，具体表现在四个方面：

<font color=orachid>**1.函数可以被引用**</font>

```python
def sum(number1, number2):    
  return number1 + number2        

func = sum
print(func(1, 2))   # 3
```

<font color=orachid>**2.函数可以作为容器类型的元素**</font>

```python
def sum(number1, number2):    
  return number1 + number2        

funcs = [sum]
print(funcs[0](1, 2))   # 3
```

<font color=orachid>**3.函数可以作为参数传入另一个函数**</font>

```python
def sum(number1, number2):    
  return number1 + number2        

def getResult(number1, number2, func):    
  return func(number1, number2)        

print(getResult(1, 2, sum)) # 3
```

<font color=orachid>**4.函数的返回值可以是一个函数**</font>

```python
def sum(number1, number2):    
  return number1 + number2        

def getFunc():    
  return sum        

print(getFunc()(1, 2)) # 3
```

# 闭包函数

&emsp;&emsp;基于函数对象的概念，可以将函数返回到任意位置去调用，但作用域的关系是在定义完函数时就已经确定了的，与函数调用的位置无关：

```python
x=1

def f1():    
  def f2():        
    print(x)    
  return f2        
  
def f3():    
  x=3    
  f2=f1() # 调用f1()返回函数f2    
  f2() # 需要按照函数定义时的作用关系去执行，与调用位置无关        
 

f3() #结果为1
```

> <font color=orange>*__注意：__*</font>也就是说当函数被当成数据处理的时候，始终以自带的作用域为准。

&emsp;&emsp;如果内嵌函数包含对外部函数作用域（不是全局作用域）中变量的引用，那么该内嵌函数就是 <font color=red>*__闭包函数（简称闭包）__*</font>：

```python
x=1

def outer():    
  x=2    
  def inner():        
    print(x)    
  return inner

func=outer()
func() # 结果为2
```

&emsp;&emsp;可以通过函数的 <font color=red>*__closure__*</font> 属性查看闭包函数所包裹的外部变量：

```python
x=1
def outer():    
  x=2    
  def inner():        
    print(x)    
  return inner        
  
func=outer()
print(func.__closure__)
# (<cell at 0x0000000001E36588: int object at 0x000000006F288090>,)
print(func.__closure__[0].cell_contents)    # 2
```

&emsp;&emsp;"闭" 代表函数是内部的，"包" 代表函数外包裹着对外层作用域的引用。因此，无论在何处调用闭包函数，使用的都是包裹在其外层的变量。目前有两种为函数传值的方式：

+ 将值以参数的形式传入
+ 将值包给函数

```python
def get_name(name):
    print(name)


def out(name):
    def print_name():
        print(name)
    return print_name
```

&emsp;&emsp;方法一在打印同一个人姓名的时候要重复传入name，而方法二只需要传一次值就会得到一个包含指定name的闭包函数，以后调用该闭包函数无须再传name：

```python
def get_name(name):
    print(name)


def out(name):
    def print_name():
        print(name)
    return print_name


get_name("张三")
get_name("张三")
get_name("张三")

out_name = out("张三")
out_name()
out_name()
out_name()
```

> <font color=orange>*__注意：__*</font>闭包函数的这种特性又称为惰性计算，使用将值包给函数的方式在装饰器中也有很大的应用。