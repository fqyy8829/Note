[toc]

# 定义函数

&emsp;&emsp;函数是带有名称的代码块，用于完成具体的工作。通过调用该函数可以执行其定义的特定任务。如果需要在程序中多次执行同一项任务，这时候无需反复编写完成该任务的代码，只要执行该任务的函数，让Python执行其中的代码即可。

&emsp;&emsp;函数的使用必须遵循<font color=red> **"先定义，后调用"** </font>的原则。函数的定义就相当于事先将函数体代码保存起来，然后将内存地址赋值给函数名，函数名就是对这段代码的引用，这和变量的定义是相似的。简单的定义函数的语法如下：

```python
def 函数名(参数1,参数2,...):
    函数体
    return 值
```

+ <font color=orchid>**def：**</font> 该关键字用来告诉Python要定义一个函数
+ <font color=orchid>**函数名：**</font> 函数名指向函数内存地址，是对函数体代码的引用（<font color=red> *函数的命名应该反映出函数的功能* </font>）
+ <font color=orchid>**括号：**</font> 括号内用来定义参数，<font color=red> *参数是可有可无的，且无需指定参数的类型* </font>
+ <font color=orchid>**冒号：**</font> 括号后要加冒号，然后在下一行开始缩进编写函数体的代码
+ <font color=orchid>**函数体：**</font> 由语句和表达式组成
+ <font color=orchid>**return值：**</font> 定义函数的返回值，<font color=red> *return是可有可无的* </font>

```python
def sayHello():
    '''
        作者：FQYY
        描述：定义了一个打印消息的函数
        返回值：无
        参数：无
    '''
    print("Hello World")
```

> <font color=orange>*__定义函数的时候发生的事情：__*</font>
> + 申请内存空间保存函数体代码
> + 将上述内存地址绑定函数名
> + 定义函数的时候不会执行函数体的代码，但是会检测函数体语法

&emsp;&emsp;函数的使用分为定义阶段与调用阶段，定义函数时只检测语法而不执行函数体代码，函数调用使用<font color=red> **函数名加括号** </font>的方式，只有调用函数时才会执行函数体代码：

```python
def sayHello():
    '''
        作者：FQYY
        描述：定义了一个打印消息的函数
        返回值：无
        参数：无
    '''
    print("Hello World")


sayHello()  # Hello World
sayHello()  # Hello World
```

> <font color=orange>*__调用函数发生的事情：__*</font>
> + 通过函数名找到函数内存地址
> + 然后加括号就是在触发函数题代码的执行

&emsp;&emsp;函数可以调用多次：

```python
def sayHello():
    '''
        作者：FQYY
        描述：定义了一个打印消息的函数
        返回值：无
        参数：无
    '''
    print("Hello World")


sayHello()  # Hello World
sayHello()  # Hello World
```

> <font color=orange>*__注意：__*</font>当函数体为<font color=red>**pass**</font>的时候代表什么都不做，称之为<font color=red> **空函数** </font>。在程序设计的开始，往往是先想好程序都需要完成什么功能，然后把所有功能都列举出来用pass充当函数体<font color=red> **"占位符"** </font>，这将使得程序的体系结构立见，清晰且可读性强。后期我们可以根据编程任务去选择性的实现上述功能来替换掉pass，从而提高开发效率：
>
>```python
> def readFile():
>    '''
>        封装一个读取文件的函数
>    '''
>    pass
>```

# 返回值

&emsp;&emsp;函数并不是总是直接显示输出，也可以处理一些数据后返回一个或者一组值：

```python
def getMessage():
    '''
        返回一个字符串
    '''
    return "Hello World"


print(getMessage()) # Hello World
```

&emsp;&emsp;return后无值或省略return，则默认返回None：

```python
def getMessage():
    return


def sayHello():
    pass


print(getMessage()) # None
print(sayHello())   # None
```

&emsp;&emsp;return的返回值无类型限制：

```python
# 返回字符串
def returnString():
    return "Hello World"
    
    
# 返回数字
def returnNumber():
    return 12
    
    
# 返回列表
def returnList():
    return [1, 2, 3, 4]
    
    
# 返回字典
def returnDic():
    return {"name": "张三", "age": 12}
    
    
# 返回元祖
def returnTuple():
    return (1, 2, 3)
    
    
# 或者
def returnValue():
    return 1, 2, 3
```

&emsp;&emsp;return是一个函数结束的标志，函数内可以有多个return，但只执行一次return函数就结束了，并把return后定义的值作为本次调用的结果返回：

```python
def getMessage():
    return "Hello World"
    return "Hello Python"


print(getMessage()) # Hello World
```

# 传递参数

&emsp;&emsp;在定义函数的时候可以传递参数，函数的参数分为形参和实参：

+ <font color=orchid>**形参：**</font> 在定义函数时，括号内声明的参数。形参本质就是一个变量名，用来接收外部传来的值
+ <font color=orchid>**实参：**</font> 在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合

```python
def greet_user(username):
    print("Hello {}".format(username))

greet_user("Jack")
greet_user("Tom")
```

&emsp;&emsp;这里的 **username** 就是一个行参，而调用的时候传入的 **"Jack"** 就是一个实参，即调用函数的时候将 **"Jack"** 传递给了 **username** 。

> <font color=orange>*__注意：__*</font> 在调用有参函数时，实参（值）会赋值给形参（变量名）。在Python中，变量名与值只是单纯的绑定关系，而对于函数来说这种绑定关系只在函数调用时生效，在调用结束后解除。

&emsp;&emsp;函数定义中可以包含多个形参，因此调用函数的时候也可以包含多个实参，向函数传递实参的方法很多。

## 位置实参

&emsp;&emsp;基于实参的顺序，要求实参的与形参的顺序相同：

```python
def greet_user(username, age):
    print("My name is {}, I'm {} years old".format(username, age))

greet_user("Jack", 16)
greet_user("Tom", 18)
```

## 关键字实参  

&emsp;&emsp;每个实参都是由变量名和值组成，因为直接在实参中将名称和值关联起来，所以向函数传递实参时不会混淆。关键字实参让你无须考虑函数调用中的实参顺序，还清楚的指出了函数调用中各个值的用途：

```python
def greet_user(username, age):
    print("My name is {}, I'm {} years old".format(username, age))


greet_user(username="Jack", age=16)

greet_user(age=18, username="Tom")
```

> <font color=orange>*__注意：__*</font> 使用关键字实参时，务必准确指定函数定义中的形参名。

&emsp;&emsp;关于关键字实参还需要注意两点：

+ 必须保证关键字参数在位置参数后面
+ 不可以对一个形参重复赋值

```python
def printInfo(username, age, gender):
    print("name: {}, age: {}, gender: {}".format(username, age, gender))
    
    
printInfo(username="Jack", 18, gender="man")    
# SyntaxError: positional argument follows keyword argument


printInfo(username="Jack", age=18, gender="man", gender="woman")    
# SyntaxError: keyword argument repeated
```

## 默认值

&emsp;&emsp;编写函数的时候，可以给每个形参指定默认值，在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则将使用形参的默认值。因此在形参指定了默认值后，可以在函数调用的时候省略相应的实参：

```python
def greet_user(username, age=20):
    print("My name is {}, I'm {} years old".format(username, age))


greet_user(username="Jack", age=19) # My name is Jack, I'm 19 years old
greet_user(username="Tom")  # My name is Tom, I'm 20 years old
```

> <font color=orange>*__注意：__*</font> 有默认值的形参必须放在没有默认值的形参的后面。

## 可变长度的参数

&emsp;&emsp;有时候预先不知道要接受多少个实参，Python允许函数从调用语句中传递任意数量的实参：

<font color=orachid>**1. 可变长度的位置参数**</font>

&emsp;&emsp;如果在最后一个形参名前加\*号，那么在调用函数时，所有溢出的位置实参都会被接收，并且会以元组的形式保存下来赋值给该形参：

```python
def func_user(*user):
    print(type(user))
    print(user)
    
    
func_user("Tom", "Jack", "Dell")
# <class 'tuple'>
# ('Tom', 'Jack', 'Dell')
```

&emsp;&emsp;即便函数只收到一个值python也会将实参封装到一个元祖中：

```python
def func_user(*user):
    print(type(user))
    print(user)
    
    
func_user("Tom")
# <class 'tuple'>
# ('Tom',)
```

&emsp;&emsp;如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后，Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中：

```python
def func_user(num1, *numbers):
    print(num1)
    print(numbers)
    
    
func_user(12,12,32,23)
# 12
# (12, 32, 23)
```

&emsp;&emsp;也可以将一个列表传递给可变参数：

```python
def func_user(num1, *numbers):
    print(num1)
    print(numbers)
    
    
func_user(1, *[2, 3, 4])
# 1
# (2, 3, 4)
```

&emsp;&emsp;这里在传入列表的时候必须在前面加上\*号，否则列表会被当成普通的位置参数传入：

```python
def func_user(num1, *numbers):
    print(num1)
    print(numbers)
    
    
func_user(1, [2, 3, 4])
# 1
# ([2, 3, 4],)
```

<font color=orachid>**2. 可变长度的关键字参数**</font>

&emsp;&emsp;如果在最后一个形参名前加\*\*号，那么在调用函数时，所有溢出的关键字参数都会被接收，并且会以字典的形式保存下来赋值给该形参：

```python
def func_user(first_name, last_name, **user_info):
    print(first_name)
    print(last_name)
    print(user_info)
    
    
func_user("Stephen", "Curry", local="American", age=32)
# Stephen
# Curry
# {'local': 'American', 'age': 32}
```

&emsp;&emsp;也可以将字典传值给可变参数：

```python
def func_user(first_name, last_name, **user_info):
    print(first_name)
    print(last_name)
    print(user_info)
    
    
info = {"local": "American", "age": 32}
func_user("Stephen", "Curry", **info)
# Stephen
# Curry
# {'local': 'American', 'age': 32}
```

&emsp;&emsp;如果在传入字典的时候没有加\*\* ，那么该字典就只是一个普通的位置参数了，此时运行程序就会报错：

```python
def func_user(first_name, last_name, **user_info):
    print(first_name)
    print(last_name)
    print(user_info)
    
    
info = {"local": "American", "age": 32}
func_user("Stephen", "Curry", info)
# TypeError: func_user() takes 2 positional arguments but 3 were given
```

## 命名关键字参数

&emsp;&emsp;前面介绍了可变长度的关键字参数，在定义了可变长度的关键字参数后，函数调用者就可以传入任意的关键字参数（key=value）。但是如果函数体代码的执行需要依赖某个key，必须在函数内进行判断：

```python
def func_user(first_name, last_name, **user_info):
    if "gender" in user_info:
        pass
```

&emsp;&emsp;如果想要限定函数的调用者必须以<font color=red> **key=value** </font>的形式传入一些值，Python3为此提供了专门的语法：在定义形参时需要使用一个\*号作为分隔符号，\*号之后的形参称为<font color=red> *__命名关键字参数__* </font>。对于这类参数，在函数调用时必须按照<font color=red> **key=value** </font>的形式为其传值，且必须被传值：

```python
def printInfo(name, age, *, gender, salary):
    pass
    
    
printInfo('lili', 18, gender='male', salary=12) # 正确使用
printInfo('lili', 18, 'male', 12) 
# # TypeError: printInfo() takes 2 positional arguments but 4 were given
printInfo('lili', 18, gender='male') 
# TypeError: printInfo() missing 1 required keyword-only argument: 'salary'
```

&emsp;&emsp;命名关键字参数也可以有默认值：

```python
def printInfo(name, age, *, gender="male", salary):
    pass
    
    
printInfo('lili', 18, salary=12)
```

&emsp;&emsp;这里的形参<font color=red> **gender='male'** </font>属于命名关键字参数的默认值，因而即便是放到形参<font color=red> **salary** </font>之前也不会有问题。

&emsp;&emsp;如果形参中已经使用\*创建了一个可变长度的参数，那么命名关键字参数就不再需要一个单独的\*作为分隔符号了：

```python
def printInfo(name, age, *info, gender="male", salary):
    pass
    
    
printInfo('lili', 18, 1,salary=12)
```

## 组合参数

&emsp;&emsp;前面介绍的所有的参数都可以任意组合使用，但定义顺序必须是：<font color=red> *__位置参数、默认参数、\*定义的可变参数、命名关键字参数、\*\*定义的可变参数__*  </font>：

```python
def printInfo(name, age=20, *args, gender="male", **kwargs):
    print(name, age, args, gender, kwargs)
    
    
printInfo("Jack", *[1,2,3], salary=20)
# Jack 1 (2, 3) male {'salary': 20}
```

> <font color=orange>*__注意：__*</font> \*args、\*\*kwargs中的args和kwargs可以被替换成其它的名称，但使用args、kwargs是约定俗成的。

## 列表参数

&emsp;&emsp;在函数中是可以修改列表的，也就是说如果将列表传入到函数，那么在函数中对列表的操作会影响到列表本身：

```python
user = ["Tom", "Jack", "Clair"]
del_user = []


def func_del_user(old_user, new_user):
    while old_user:
        new_user.append(old_user.pop())


func_del_user(user, del_user)

print(user) # []
print(del_user) # ['Clair', 'Jack', 'Tom']
```

> <font color=orange>*__注意：__*</font>python的传递是内存地址的传递。

&emsp;&emsp;如果想要禁止修改列表，可以使用下面的方法：

```python
user = ["Tom", "Jack", "Clair"]
del_user = []


def func_del_user(old_user, new_user):
    while old_user:
        new_user.append(old_user.pop())


func_del_user(user[:], del_user)

print(user) #  ["Tom", "Jack", "Clair"]
print(del_user) # ['Clair', 'Jack', 'Tom']
```