[toc]

# 算术运算符

&emsp;&emsp;python支持的算数运算符与数学上计算的符号使用是一致的（x = 5 , y = 2）：

|算术运算符|描述  | 示例 |
|--|--|--|
| + | 两个对象相加 | x + y = 7 |
| - | 两个对象相减 | x - y = 3 |
| * | 两个对象相乘 | x * y = 10 |
| / | 除，返回值保留整数和小数部分 | x / y = 2.5 |
| // | 整除，只保留整数部分 | x // y = 2 |
| % | 取余数 | x % y = 1 |
| ** | 一个数的n次方  | x ** y = 25 |

```python
x = 5 
y = 2 
print(f"x + y = {x + y}") 
print(f"x - y = {x - y}") 
print(f"x * y = {x * y}") 
print(f"x / y = {x / y}") 
print(f"x // y = {x // y}") 
print(f"x % y = {x % y}") 
print(f"x ** y = {x ** y}") 
# x + y = 7 
# x - y = 3 
# x * y = 10 
# x / y = 2.5 
# x // y = 2 
# x % y = 1 
# x ** y = 25
```

# 比较运算符

&emsp;&emsp;比较运算用来对两个值进行比较，返回的是布尔值（x = 5，y = 2）：

|比较运算符|描述  | 示例 |
|--|--|--|
| == | 相等 | x ==y   // False |
| != | 不相等 | x !=y   // True |
| > | 大于 | x > y  // True |
| >= | 大于等于 | x >= y // True |
| < | 小于 | x < y  // False |
| <= | 小于等于 | x <= y // False |

```python
x = 5
y = 2
print(f"x == y = {x == y}")
print(f"x != y = {x != y}")
print(f"x > y = {x > y}")
print(f"x >= y = {x >= y}")
print(f"x < y = {x < y}")
print(f"x <= y = {x <= y}")

# x == y = False
# x != y = True
# x > y = True
# x >= y = True
# x < y = False
# x <= y = False
```

# 赋值运算符

&emsp;&emsp;python语法中除了有=号这种简单的赋值运算外，还支持增量赋值、链式赋值、交叉赋值、解压赋值，这些赋值运算符存在的意义都是为了让我们的代码看起来更加精简。

## 增量赋值

|赋值运算符|描述  | 示例 |
|--|--|--|
| += | 加法赋值运算符 | x += 1  相当于 x = x + 1 |
| -= | 减法赋值运算符 | x -= 1  相当于 x = x - 1 |
| *= | 乘法赋值运算符 | x *= 1  相当于 x = x * 1 |
| /= | 除法赋值运算符 | x /= 1  相当于 x = x / 1 |
| //= | 整除赋值运算符 | x //= 1  相当于 x = x // 1 |
| %= | 取余赋值运算符 | x %= 1  相当于 x = x % 1 |
| **= | 幂赋值运算符  | x \*\*= 1  相当于 x = x ** 1 |

```python
x = 5 
x += 2 
print(f"x += 2 = {x}")  # 7 
x = 5 
x -= 2 
print(f"x -= 2 = {x}")  # 3 
x = 5 
x *= 2 
print(f"x *= 2 = {x}")  # 10 
x = 5 
x /= 2 
print(f"x /= 2 = {x}")  # 2.5 
x = 5 
x //= 2 
print(f"x //= y = {x}") # 2 
x = 5 
x %= 2 
print(f"x %= y = {x}")  # 1 
x = 5 
x **= 2 
print(f"x **= y = {x}") # 25
```

## 链式赋值

&emsp;&emsp;如果我们想把同一个值同时赋值给多个变量名可以这么做：

```python
z = 10 
y = z 
x = y 
print(x, y, z) # 10 10 10
```

&emsp;&emsp;链式赋值指的是可以用一行代码搞定这件事：

```python
x = y = z = 10 
print(x, y, z)    # 10 10 10
```

## 交叉赋值

&emsp;&emsp;如果我们想交换两个变量的值可以这么做：

```python
x = 10 
y = 20 
print(f"x = {x}, y = {y}")  
# x = 10, y = 20 

temp = x 
x = y 
y = temp 
print(f"x = {x}, y = {y}")  # x = 20, y = 10
```

&emsp;&emsp;交叉赋值指的是一行代码可以搞定这件事：

```python
x = 10 
y = 20 
print(f"x = {x}, y = {y}")  # x = 10, y = 20 

x, y = y, x 
print(f"x = {x}, y = {y}")  # x = 20, y = 10
```

## 解压赋值

&emsp;&emsp;如果我们想把列表中的多个值取出来依次赋值给多个变量名可以这么做：

```python
numbers = [1, 2, 3] 
a = numbers[0] 
b = numbers[1] 
c = numbers[2] 
print(a, b, c)  # 1 2 3
```

&emsp;&emsp;解压赋值指的是一行代码可以搞定这件事：

```python
numbers = [1, 2, 3] 
a, b, c = numbers 
print(a, b, c)  # 1 2 3
```

&emsp;&emsp;解压赋值时等号左边的变量名个数必须与右面包含值的个数相同，否则会报错：

```python
numbers = [1, 2, 3] 
# 变量个数少了 
a, b = numbers 
# Traceback (most recent call last): 
#   File "/Users/fqyy/Downloads/Code/Learn/Python/demo.py", line 3, in <module> #     a, b = numbers 
# ValueError: too many values to unpack (expected 2) 

# 变量个数多了 
a, b, c, d = numbers 
# Traceback (most recent call last): 
#   File "/Users/fqyy/Downloads/Code/Learn/Python/demo.py", line 11, in <module> 
#     a, b, c, d = numbers 
# ValueError: not enough values to unpack (expected 4, got 3)
```

&emsp;&emsp;如果我们只想取头尾的几个值可以用 <font color=red>*__\*变量名__*</font> 进行匹配，此时Python会将没有对应关系的值存成列表然后赋值给紧跟其后的变量名：

```python
numbers = [1, 2, 3, 4, 5, 6] 
# 取前面两个 
a, b, *_ = numbers print(a, b)     # 1 2 

# 取后面两个 
*_, a, b = numbers print(a, b)     # 5 6
```

> <font color=orange>*__注意：__*</font> 这里的 _  是变量名，一般自己定义变量的时候不要使用下划线（ _ ）开头和结尾，或者直接使用下划线（ _ ），从Python的规范上来说它们都有特殊的用处，所有自己定义的变量不要去用。比如这里直接使用下划线（ _ ）接受数据表示该变量一般不会使用，仅仅做为占位符。

&emsp;&emsp;除了列表外，字符串、字典、元组、集合类型都支持解压赋值：

```python
# 列表 
l = [1, 2, 3] 
a, b, c = l 
print(a, b, c)  # 1 2 3 

# 元祖 
t = (4, 5, 6) 
a, b, c = t 
print(a, b, c)  # 4 5 6 

# 集合 
s = {7, 8, 9} 
a, b, c = s 
print(a, b, c)  # 8 9 7 

# 字符串 
a, b, c = "abc" 
print(a, b, c)  # a b c 

# 字典  获取的是key值 
a, b, c = {"name": "Tom", "age": 18, "gender": "男"} 
print(a, b, c)  # name age gender
```

# 逻辑运算符

| 逻辑运算符 | 描述 |
|--|--|
| and | 逻辑与，只有当两个对象都是True的时候返回True， 否则返回False |
| or | 逻辑或，只有当两个对象都是False的时候返回False，否则返回True |
| not | 取反 |

&emsp;&emsp;逻辑运算符用于连接多个条件进行关联判断，会返回布尔值：

```python
# 逻辑与 
print(1 and 2)  # 2 
print(1 and 0)  # 0 
print(0 and 0)  # 0 

# 逻辑或 
print(1 or 2)   # 1 
print(1 or 0)   # 1 
print(0 or 0)   # 0 

# 逻辑非 
print(not 1)    # False 
print(not 0)    # True
```

&emsp;&emsp;可以用and连接多个条件，会按照从左到右的顺序依次判断，一旦某一个条件为False，则无需再往右判断，可以立即判定最终结果就为False；只有在所有条件的结果都为True的情况下，最终结果才为True：

```python
# 多个and 
# 有一个是False就为False 
print(1 and 0 and 2)    # 0 
# 全部是True的时候才是True 
print(1 and 2 and 3)    # 3
```

&emsp;&emsp;同样也可以用or连接多个条件，此时会按照从左到右的顺序依次判断，一旦某一个条件为True，则无需再往右判断，可以立即判定最终结果就为True；只有在所有条件的结果都为False的情况下，最终结果才为False：

```python
# 多个or 
# 有一个是True就是True 
print(1 or 0 or 2)  # 1 
# 全部是False的时候才是False 
print(0 or 0 or 0)  # 0
```

> <font color=orange>*__注意：__*</font> 三者的优先级关系 <font color=red> *__not > and > or__* </font>，同一优先级默认从左往右计算。最好使用括号来区别优先级，其实意义与上面的一样。

&emsp;&emsp;逻辑运算的结果一旦可以确定，那么就以当前处计算到的值作为最终结果返回，这种现象叫做 <font color=red>*__短路运算__*</font>：

```python
# 因为or只要有一个为True就是True，因此当获取到1后不会在执行后面的 
print(1 or 0 or 2)    # 1 
# 因为or只要有一个为False就是False，因此当获取到0后不会在执行后面的 
print(0 and 1 and 2)    # 0
```

# 成员运算符

|成员运算符| 描述 |
|--|--|
| in | 某个对象是否包含另一个对象，字符串、列表、元祖、集合和字典都支持 |
| not in | 某个对象是否不包含另一个对象 |

```python
# 字符串 
print('a' in 'Hello')       # False 
print('a' not in 'Hello')   # Ture 

# 字典 默认判断是的key 
print('a' in {"name": "age"})   # False 
print('a' not in {"name": "age"})   # True 

# 集合 
print('a' in {'a', 'b'})    # True 
print('a' not in {'a', 'b'})    # False 

# 列表 
print('a' in ['a', 'b'])    # True 
print('a' not in ['a', 'b'])    # False 

# 元祖 
print('a' in ('a', 'b'))    # True 
print('a' not in ('a', 'b'))    # False
```

> <font color=orange>*__注意：__*</font> 虽然两种判断可以达到相同的效果，但推荐使用not in，因为它的语义更加明确。

# 身份运算符

|身份运算符| 描述 |
|--|--|
| is | 某个对象是否包含另一个对象，字符串、列表、元祖、集合和字典都支持 |
| is not | 某个对象是否不包含另一个对象 |

```python
x = "Hello World" 
y = "Hello World" 
z = x 
print(x is y)  # False 
print(x is not y)  # True 
print(x is z)      # True 
print(x is not z)  # False
```