[toc]

# 函数递归

&emsp;&emsp;函数不仅可以嵌套定义还可以嵌套调用，即在调用一个函数的过程中，在其内部又调用另一个函数。<font color=red> *__函数的递归调用指的是在调用一个函数的过程中又直接或间接地调用该函数本身__* </font>：

```python
# 直接调用本身
def f1():
    print('from f1')
    f1()
    
# 间接调用
def f2():
    print('from f2')
    f3()

def f3():
    print('from f3')
    f2()
```

&emsp;&emsp;上述的两种情况下的递归调用都是一个无限循环的过程（<font color=red>*__python对函数的递归调用的深度做了限制，因而并不会进入无限循环，而是会抛出异常__*</font>），要避免出现这种情况，就必须让递归调用在满足某个特定条件下终止：

```python
def sum(number):
    if number == 1:
        return 1
    return number + sum(number - 1)
    
    
print(sum(5))   # 15
```

> <font color=orange>*__注意：__*</font> 可以使用<font color=red> *__sys.getrecursionlimit()方法__* </font>去查看递归深度（默认值为1000），虽然也可以使用<font color=red> *__sys.setrecursionlimit()方法__* </font>去设定该值，但仍会受到主机操作系统栈大小的限制。

## 二分法

&emsp;&emsp;有一个按照从小到大顺序排列的数字列表，需要从该数字列表中找到想要的某个数字：

```python
numbers = [-1, 2, 5, 8, 9, 10, 20]


def find_number(nums, number):
    if len(nums) == 0:
        print("not in")
        return
    mid = len(nums) // 2
    if nums[mid] > number:
        find_number(nums[0: mid], number)
    elif nums[mid] < number:
        find_number(nums[mid + 1:], number)
    else:
        print("find it")


find_number(numbers, 11)
```

# 匿名函数与lambda

&emsp;&emsp;使用def关键字创建的是有名字的函数，而lambda关键字创建则是没有名字的函数（即匿名函数），语法如下：

```python
lambda 参数1,参数2,...: expression
```

```python
lambda x, y, z: x + y + z

# 等同于
# def func(x, y, z):
#     return x + y + z

# 调用方式一：
print((lambda x, y, z: x + y + z)(1, 2, 3))

# 调用方式二：
func = lambda x, y, z: x + y + z  
# “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的
print(func(1, 2, 3))
```

&emsp;&emsp;匿名函数主要用于临时使用一次的场景，它通常与其它函数配合使用：

<font color=orachid>**1.max和min方法**</font>

&emsp;&emsp;内置max和min都支持迭代器协议，当迭代字典的时候默认取得是字典的键，因而比较的是键的最大和最小值，但是通常情况下我们需要得到的是值的最大值与最小值，于是做出如下改动：

```python
salary = {
    "Jack": 12,
    "Tom": 20,
    "Helen": 7
}
print(max(salary, key=lambda k: salary[k])) # Tom
print(min(salary, key=lambda k: salary[k])) # Helen
```

&emsp;&emsp;max会迭代内容，并将迭代的返回值作为key参数的函数中的参数，使用key指定的值作为比较工具。

<font color=orachid>**2.sorted方法**</font>

&emsp;&emsp;sorted方法默认也是对字典的键进行排序，如果需要对值进行排序，可以使用下面的方法：

```python
salary = {
    "Jack": 12,
    "Tom": 20,
    "Helen": 7
}
print(sorted(salary, key=lambda k: salary[k]))  # ['Helen', 'Jack', 'Tom']
```

<font color=orachid>**3.map方法**</font>

```python
for number in map(lambda n: n**2, [1, 2, 3]):
    print(number)
    
# 1
# 4
# 9
```

&emsp;&emsp;map会依次迭代array，然后将得到的值依次传给匿名函数（也可以是有名函数），map函数得到的结果仍然是迭代器。

<font color=orachid>**4.reduce方法**</font>

&emsp;&emsp;reduce函数可以接收三个参数：函数、可迭代对象和初始值：

```python
from functools import reduce
sum = reduce(lambda x,y: x + y, [1,2,3])
print(sum)  # 6
```

&emsp;&emsp;它的运行原理如下：

+ 在没有初始值的时候reduce函数会先迭代一次array，将得到的值作为初始值传给x
+ 然后继续迭代一次array得到的值作为第二个值传给y，运算的结果为3 
+ 将上一次reduce运算的结果作为第一个值传给x
+ 然后迭代一次array得到的结果作为第二个值传给y
+ 依次类推，直到迭代完array的所有元素，得到最终的结果6
    
&emsp;&emsp;也可以给定初始值：

```python
from functools import reduce
sum = reduce(lambda x,y: x + y, [1,2,3], 100)
print(sum)  # 106
```

<font color=orachid>**5.filter方法**</font>

&emsp;&emsp;filter函数会依次迭代array，得到的值依次传给匿名函数，如果匿名函数的返回值为真，则过滤出该元素，而filter函数得到的结果仍然是迭代器。 

```python
for number in filter(lambda x: x % 2 == 0, [1,2,3,4,5,6,7,8]):
    print(number, end=" ")  # 2 4 6 8 
```