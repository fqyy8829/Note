[toc]

# 名称空间

&emsp;&emsp;名称空间就是存放名字与对象映射（或者绑定）关系的地方，比如：<font color=red>**x=3** </font>，在Python中会申请内存空间存放对象 3，然后将名字x与3的绑定关系存放于名称空间中（使用<font color=red> **del x** </font>可以清除该绑定关系）。在程序执行期间最多会存在三种名称空间：

<font color=orachid>**1. 内建名称空间**</font>

&emsp;&emsp;伴随python解释器的启动/关闭而产生/回收，因而是第一个被加载的名称空间，用来存放一些内置的名字，比如内建函数名：

```python
print(max)  # <built-in function max>
# 这里的built-in就是内建的意思
```

<font color=orachid>**2. 全局名称空间**</font>

&emsp;&emsp;伴随python文件的 开始执行/执行完毕 而 产生/回收，是第二个被加载的名称空间，文件执行过程中产生的名字都会存放于该名称空间中（顶级代码所产生的名字，即：不在函数内，也不是内置的）：

```python
import sys #模块名sys

x=1 #变量名x

if x == 1:
    y=2 #变量名y

def foo(x): #函数名foo
    pass

Class Bar: #类名Bar
    pass
```

<font color=orachid>**3. 局部名称空间**</font>

&emsp;&emsp;伴随函数的调用/结束而临时产生/回收，函数的形参、函数内定义的名字都会被存放于该名称空间中：

```python
def foo(x):
    y=3 #调用函数时，才会执行函数代码，名字x和y都存放于该函数的局部名称空间中
```

&emsp;&emsp;名称空间的加载顺序是：<font color=red> *__内置名称空间->全局名称空间->局部名称空间__* </font>，当查找一个名字的时候必须从三个名称空间之一找到，查找顺序为：<font color=red> *__局部名称空间->全局名称空间->内置名称空间__* </font>。<font color=red>而名称空间的嵌套关系是以定义为准的</font>：

```python
x = 1
def func():
    print(x)
 
def foo():
    x = 222
    # 会从函数func定义的名称开始查找
    func()

foo()   # 1
```

# 作用域
## 全局作用域与局部作用域

&emsp;&emsp;按照名字作用范围的不同可以将三个名称空间划分为两个区域：

+ <font color=orchid>**全局作用域：**</font> 位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）
+ <font color=orchid>**局部作用域：**</font> 位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）

## 作用域与名字查找的优先级

&emsp;&emsp;在局部作用域查找名字时，起始位置是局部作用域，所以先查找局部名称空间，如果没有找到再去全局作用域查找，这个时候会先查找全局名称空间，如果没有找到再去查找内置名称空间，如果最后都没有找到就会抛出异常：

```python
x = 100
def func():
    x = 200
    print(x)
    
    
func()  # 200
```

&emsp;&emsp;在全局作用域查找名字时，起始位置便是全局作用域，所以先查找全局名称空间，如果没有找到再去查找内置名称空间，最后都没有找到就会抛出异常：

```python
x = 100
def func():
    x = 200
    print(x)
    
    
print(x)    # 100
```

&emsp;&emsp;可以调用内建函数<font color=red> **locals()** </font>和<font color=red> **globals()** </font>来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式（在全局作用域查看到的locals()的结果等于globals()）：

```python
x = 1
def func():
    y = 20
    print(locals())
    print(globals())
    
    
func()
# {'y': 20}
# {'__name__': '__main__', '__doc__': None, 
# '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x0000000001DEB080>, 
# '__spec__': None, '__annotations__': {}, 
# '__builtins__': <module 'builtins' (built-in)>, 
# '__file__': 'd:/code/Python/demo.py', 
# '__cached__': None, 'x': 1, 'func': <function func at 0x00000000004D2EA0>}

print(locals())

# {'__name__': '__main__', '__doc__': None, 
# '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x0000000001DEB080>, 
# '__spec__': None, '__annotations__': {}, 
# '__builtins__': <module 'builtins' (built-in)>, 
# '__file__': 'd:/code/Python/demo.py', 
# '__cached__': None, 'x': 1, 'func': <function func at 0x00000000004D2EA0>}

print(globals())

# {'__name__': '__main__', '__doc__': None, 
# '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x0000000001DEB080>, 
# '__spec__': None, '__annotations__': {}, 
# '__builtins__': <module 'builtins' (built-in)>, 
# '__file__': 'd:/code/Python/demo.py', 
# '__cached__': None, 'x': 1, 'func': <function func at 0x00000000004D2EA0>}
```

&emsp;&emsp;Python支持函数的嵌套定义，在内嵌的函数内查找名字时会优先查找自己局部作用域的名字，然后由内而外一层层查找外部嵌套函数定义的作用域，没有找到则查找全局作用域，如果最终没有找到就会报错：

```python
x=1
def outer():
    x=2
    def inner(): # 函数名inner属于outer这一层作用域的名字
        x=3
        print('inner x:%s' %x)
    inner()
    print('outer x:%s' %x)

outer() 
# inner x:3
# outer x:2
```

&emsp;&emsp;在函数内无论嵌套多少层都可以查看到全局作用域的名字，若要在函数内修改全局名称空间中名字的值，当值为不可变类型时，则需要用到<font color=red> **global** </font>关键字：

```python
x=1
def foo():
    global x #声明x为全局名称空间的名字
    x=2


foo()
print(x) #结果为2
```

&emsp;&emsp;对于可变类型的值，可以通过传参的方式去修改：

```python
num_list=[1,2,3]
def foo(nums):
    nums.append(5)

foo(num_list)
print(num_list)#结果为[1, 2, 3, 5]
```

&emsp;&emsp;对于嵌套多层的函数，使用<font color=red> **nonlocal** </font>关键字可以将名字声明为来自外部嵌套函数定义的作用域（非全局）：

```python
def  f1():
    x=2
    def f2():
        nonlocal x
        x=3
    f2() #调用f2(),修改f1作用域中名字x的值
    print(x) #在f1作用域查看x

f1()    # 3
```

&emsp;&emsp;nonlocal会从当前函数的外层函数开始一层层去查找，若是一直到最外层函数都找不到，则会抛出异常。